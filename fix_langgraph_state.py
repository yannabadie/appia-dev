#!/usr/bin/env python3
"""
Correction des fonctions LangGraph pour éviter InvalidUpdateError
"""

import re


def fix_function_returns():
    """Corriger toutes les fonctions pour retourner un nouvel état"""

    with open("grok_orchestrator.py", "r", encoding="utf-8") as f:
        content = f.read()

    # Patterns de corrections
    corrections = [
        # Corriger generate_code
        (
            r'def generate_code\(state: AgentState\) -> AgentState:\s*prompt = f[^}]+state\["code_generated"\] = query_grok\(prompt, state\)[^}]+return state',
            """def generate_code(state: AgentState) -> AgentState:
    prompt = f"Génère code/fix pour '{state['task']}' sur {state['sub_agent']}. Utilise env/secrets (e.g., SUPABASE_SERVICE_ROLE auth, GCP_SA_JSON cloud). Si générer JARVYS_AI, output pour push appIA."
    code_generated = query_grok(prompt, state)

    if "générer JARVYS_AI" in state["task"].lower() or state["sub_agent"] == "AI":
        os.chdir(REPO_DIR_AI)
        # Créer la structure si elle n'existe pas
        os.makedirs("src/jarvys_ai", exist_ok=True)
        file_path = f"src/jarvys_ai/generated_{state['task'].replace(' ', '_')}.py"
        with open(file_path, "w") as f:
            f.write(code_generated)
        os.system(
            f"git add . && git commit -m 'Generated by JARVYS_DEV: {state['task']}' && git push origin main"
        )
        os.chdir("/workspaces/appia-dev")

    return {**state, "code_generated": code_generated}""",
        ),
        # Corriger apply_test
        (
            r"def apply_test\(state: AgentState\) -> AgentState:[^}]+return state",
            """def apply_test(state: AgentState) -> AgentState:
    file_path = f"src/jarvys_{state['sub_agent'].lower()}/updated_{state['task'].replace(' ', '_')}.py"
    with open(file_path, "w") as f:
        f.write(state["code_generated"])

    # Re-fix lint post-génération
    subprocess.run(f"ruff check --fix {file_path}", shell=True)

    test_result = subprocess.run(
        f"pytest {file_path}", shell=True, capture_output=True, text=True
    ).stdout
    
    new_log_entry = {
        **state["log_entry"],
        "test_result": test_result[:500],
    }
    
    try:
        supabase.table("logs").update(new_log_entry).eq(
            "task", state["task"]
        ).execute()
    except Exception as db_e:
        print(f"Supabase update failed: {db_e} – using local log fallback")
        with open("local_logs.json", "a") as f:
            json.dump(new_log_entry, f)

    return {**state, "test_result": test_result, "log_entry": new_log_entry}""",
        ),
        # Corriger update_docs
        (
            r"def update_docs\(state: AgentState\) -> AgentState:[^}]+return state",
            """def update_docs(state: AgentState) -> AgentState:
    prompt = f"Génère update doc Markdown pour '{state['task']}' sur {state['sub_agent']}. Sections: Description, Changements, Impact, Exemples. Créatif: Ajoute analogies/ideas fun alignées."
    doc_update = query_grok(prompt, state)

    with open("README.md", "a") as f:
        f.write(
            f"\\n## Update: {state['task']} ({time.strftime('%Y-%m-%d')})\\n{doc_update}\\n"
        )

    os.system("git add README.md")
    
    new_log_entry = {**state["log_entry"], "doc_update": doc_update[:500]}
    
    try:
        supabase.table("logs").update(new_log_entry).eq(
            "task", state["task"]
        ).execute()
    except Exception as db_e:
        print(f"Supabase update failed: {db_e} – using local log fallback")
        with open("local_logs.json", "a") as f:
            json.dump(new_log_entry, f)

    return {**state, "doc_update": doc_update, "log_entry": new_log_entry}""",
        ),
        # Corriger reflect_commit
        (
            r"def reflect_commit\(state: AgentState\) -> AgentState:[^}]+return state",
            """def reflect_commit(state: AgentState) -> AgentState:
    if "FAILED" in state["test_result"]:
        prompt = f"Reflect: Failed '{state['test_result']}'. Improve, créatif/proactif (alt approaches), adaptable (handle unknown)."
        reflection = query_grok(prompt, state)
        new_log_entry = {**state["log_entry"], "reflection": reflection}
        
        try:
            supabase.table("logs").update(new_log_entry).eq(
                "task", state["task"]
            ).execute()
        except Exception as db_e:
            print(f"Supabase update failed: {db_e} – using local log fallback")
            with open("local_logs.json", "a") as f:
                json.dump(new_log_entry, f)
                
        return {**state, "reflection": reflection, "log_entry": new_log_entry}
    else:
        os.system(
            f"git add . && git commit -m 'Grok Auto: {state['task']} with docs' && git push origin grok-evolution"
        )
        pr = state["repo_obj"].create_pull(
            title=f"Grok PR: {state['task']}",
            body=f"Code: {state['code_generated']}\\nDocs: {state['doc_update']}\\nLog: {str(state['log_entry'])}",
            head="grok-evolution",
            base="main",
        )
        
        new_log_entry = {**state["log_entry"], "pr_url": pr.html_url}

        # Transparence: Créer issue avec full log
        state["repo_obj"].create_issue(
            title=f"Grok Log: {state['task']} Completed", body=str(new_log_entry)
        )

        new_log_entry = {**new_log_entry, "status": "completed"}
        
        try:
            supabase.table("logs").update(new_log_entry).eq(
                "task", state["task"]
            ).execute()
        except Exception as db_e:
            print(f"Supabase update failed: {db_e} – using local log fallback")
            with open("local_logs.json", "a") as f:
                json.dump(new_log_entry, f)

    return {**state, "log_entry": new_log_entry}""",
        ),
    ]

    # Appliquer les corrections
    for pattern, replacement in corrections:
        content = re.sub(pattern, replacement, content, flags=re.MULTILINE | re.DOTALL)

    # Sauvegarder
    with open("grok_orchestrator.py", "w", encoding="utf-8") as f:
        f.write(content)

    print("✅ Corrections appliquées pour éviter InvalidUpdateError")


if __name__ == "__main__":
    fix_function_returns()
